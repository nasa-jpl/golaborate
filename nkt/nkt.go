// Package nkt enables working with NKT SuperK supercontinuum lasers.
//
// The wrapping of the individual submodules could
// be made more ergonomic in Go, but no one
package nkt

import (
	"encoding/json"
	"errors"
	"io"
	"math"
	"net/http"
	"time"

	"github.com/nasa-jpl/golaborate/comm"
	"github.com/nasa-jpl/golaborate/generichttp"
	"github.com/nasa-jpl/golaborate/generichttp/laser"

	"github.com/nasa-jpl/golaborate/util"

	"github.com/tarm/serial"
)

// messages are encoded as [SOT][MESSAGE][EOT].
// SOT and EOT are declared in the const ( ... ) block below
// the message is formatted as
// [DEST] [SOURCE] [TYPE] [REGISTER] [0..240 data bytes] [CRC]

// makeSerConf makes a new serial config
func makeSerConf(addr string) serial.Config {
	return serial.Config{
		Name:        addr,
		Baud:        115200,
		Size:        8,
		Parity:      serial.ParityNone,
		StopBits:    serial.Stop1,
		ReadTimeout: 1 * time.Second}
}

var (
	// ErrUnknownAddr is generated by an invalid address
	ErrUnknownAddr = errors.New("address is not a member of nkt.StandardAddresses or known to the module")

	// StandardAddresses maps some addresses present for all modules
	StandardAddresses = map[string]byte{
		"TypeCode":         0x61,
		"Firmware Version": 0x64,
		"Serial":           0x65,
		"Status":           0x66,
		"ErrorCode":        0x67,
	}

	// ModuleTypeMap maps bytes to human-readable strings for module types
	ModuleTypeMap = map[byte]string{
		0x0:  "N/A",
		0x60: "SuperK Extreme",
		0x61: "SuperK Front Panel",
		0x65: "SuperK Booster",
		0x68: "SuperK Varia",
		0x6B: "SuperK Extend UV",
		0x74: "SuperK COMPACT",
	}
)

// ModuleInformation is a struct holding information needed to communicate with a given module.
type ModuleInformation struct {
	// Addresses is a map from friendly names like "Emission" to byte codes (hardware addresses)
	Addresses map[string]byte
	// CodeBanks maps friendly names like "Statuses" to bitfield maps
	CodeBanks map[string]map[int]string

	// Decoders maps friendly names like "Emission" to decoding functions that return a thinning json-serializable object
	Decoders map[string]func([]byte) generichttp.HumanPayload
}

// Module objects have an address and information struct
type Module struct {
	// AddrDev is the module address on the NKT device itself
	AddrDev byte

	// Info contains mapping data for a given module, see ModuleInformation for more docs.
	Info *ModuleInformation

	pool *comm.Pool // pointer so that pool is shared between modules
}

func (m *Module) getRegister(addrName string) (byte, error) {
	var register byte
	if value, ok := m.Info.Addresses[addrName]; ok {
		register = value
	} else if value, ok = StandardAddresses[addrName]; ok {
		register = value
	} else {
		return 0, errors.New("addrName is not a register known to the module or nkt.StandardAddresses")
	}
	return register, nil
}

// SendRecvMP sends a buffer after appending the Tx terminator,
// then returns the response with the Rx terminator stripped
func (m *Module) SendRecvMP(mp MessagePrimitive) (MessagePrimitive, error) {
	var ret MessagePrimitive
	// set up the connection to the device
	conn, err := m.pool.Get()
	if err != nil {
		return ret, err
	}
	defer func() { m.pool.ReturnWithError(conn, err) }()

	send, err := mp.EncodeTelegram()
	if err != nil {
		return ret, err
	}

	// try to send the message up to 3 times.  transient CRC errors are pretty common with the NKTs
	for idx := 0; idx < 5; idx++ {
		_, err = conn.Write(send)
		if err != nil {
			return ret, err
		}
		buf := make([]byte, 64) // messages are typically close to 10 bytes, 64 is plenty
		n, err := conn.Read(buf)
		if err != nil {
			return ret, err
		}
		ret, err = DecodeTelegram(buf[:n])
		if err == nil {
			break
		}
		mp.Src = getSourceAddr()
	}
	return ret, err
}

// GetValue reads a register
func (m *Module) GetValue(addrName string) (MessagePrimitive, error) {
	var (
		ret MessagePrimitive
		err error
	)
	register, err := m.getRegister(addrName)
	if err != nil {
		return ret, err
	}
	send := MessagePrimitive{
		Dest:     m.AddrDev,
		Src:      getSourceAddr(), // GSA returns a quasi-unique source address (up to ~154 per message interval)
		Register: register,
		Type:     "Read"}

	return m.SendRecvMP(send)
}

//SetValue writes a register
func (m *Module) SetValue(addrName string, data []byte) (MessagePrimitive, error) {
	var (
		ret MessagePrimitive
		err error
	)
	register, err := m.getRegister(addrName)
	if err != nil {
		return ret, err
	}
	send := MessagePrimitive{
		Dest:     m.AddrDev,
		Src:      getSourceAddr(), // GSA returns a quasi-unique source address (up to ~154 per message interval)
		Register: register,
		Type:     "Write",
		Data:     data}

	return m.SendRecvMP(send)
}

// SetFloat converts a float to limited precision uint16 and writes it to the module
func (m *Module) SetFloat(addr string, value float64) error {
	intt := uint16(math.Round(value * 10))
	buf := make([]byte, 2, 2)
	dataOrder.PutUint16(buf, intt)
	_, err := m.SetValue(addr, buf)
	return err
}

// GetFloat returns a floating point value, rounded to nearest 0.1
// from the module
func (m *Module) GetFloat(addr string) (float64, error) {
	resp, err := m.GetValue(addr)
	if err != nil {
		return 0, err
	}
	return float64(dataOrder.Uint16(resp.Data)) / 10, err
}

// GetUint32 returns a 32-bit unsigned integer from the module
func (m *Module) GetUint32(addr string) (uint32, error) {
	resp, err := m.GetValue(addr)
	if err != nil {
		return 0, err
	}
	return dataOrder.Uint32(resp.Data), err
}

// GetStatus gets the status bitfield and converts it into a map of descriptive strings to booleans
func (m *Module) GetStatus() (map[string]bool, error) {
	// declare the response and get the response from the NKT
	resp := map[string]bool{}
	mp, err := m.GetValue("Status")
	if err != nil {
		return resp, err
	}
	// pop the bitfield and codebank for the module's status codes
	bitfield := mp.Data
	codebank := m.Info.CodeBanks["Status"]
	if len(bitfield) == 0 {
		return nil, errors.New("empty response from NKT to status query")
	}

	// loop over the number of bits in the codebank (which may be more than 1 byte in size)
	// each time we are modulo 8, we increment the offset
	nbits := uint(len(codebank))
	idx := uint(0)
	byteOffset := 0
	for (idx) < nbits { // 8 bits per byte
		if text, ok := codebank[int(idx)]; ok {
			bidx := idx - uint(byteOffset*8)
			resp[text] = util.GetBit(bitfield[byteOffset], bidx)
		}
		// increment the loop
		idx++
		if idx%8 == 0 {
			// if we are on a byte boundary, incremement the byte offset and roll down the index
			byteOffset++
		}
	}
	delete(resp, "-")
	return resp, nil
}

// SuperK is a struct holding all of the usual modules
type SuperK struct {
	*SuperKExtreme
	*SuperKVaria
	*SuperKBooster
}

// NewSuperK returns a new laser with pre-configured varia and extreme modules
func NewSuperK(addr string, connectSerial bool) *SuperK {
	var maker comm.CreationFunc
	// make the maker func
	if connectSerial {
		maker = func() (io.ReadWriteCloser, error) {
			conf := makeSerConf(addr)
			return serial.OpenPort(&conf)
		}
	} else {
		maker = comm.BackingOffTCPConnMaker(addr, 3*time.Second)
	}
	pool := comm.NewPool(1, 30*time.Second, maker)
	extreme := NewSuperKExtreme(addr, pool)
	varia := NewSuperKVaria(addr, pool)
	booster := NewSuperKBooster(addr, pool)
	return &SuperK{SuperKExtreme: extreme, SuperKVaria: varia, SuperKBooster: booster}
}

// StatusMain retrieves the main module status
func (sk *SuperK) StatusMain() (map[string]bool, error) {
	return sk.SuperKExtreme.GetStatus()
}

// StatusVaria retrieves the Varia module status
func (sk *SuperK) StatusVaria() (map[string]bool, error) {
	return sk.SuperKVaria.GetStatus()
}

func encodeStatus(fcn func() (map[string]bool, error)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		status, err := fcn()
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusOK)
		err = json.NewEncoder(w).Encode(status)
		if err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}
		return

	}
}

type AugmentedLaserController interface {
	laser.Controller
	StatusMain() (map[string]bool, error)
	StatusVaria() (map[string]bool, error)
}

// NewHTTPWrapper creates a new HTTP wrapper and populates the route table
func NewHTTPWrapper(sk AugmentedLaserController) laser.HTTPLaserController {
	w := laser.NewHTTPLaserController(sk)
	rt := w.RT()
	rt[generichttp.MethodPath{Method: http.MethodGet, Path: "/main-module-status"}] = encodeStatus(sk.StatusMain)
	rt[generichttp.MethodPath{Method: http.MethodGet, Path: "/varia-status"}] = encodeStatus(sk.StatusVaria)
	return w
}
